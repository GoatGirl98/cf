#include <bits/stdc++.h>
#define watch(x) std::cout << (#x) << " is " << (x) << std::endl
using LL = long long;


// 多线程函数获取返回值的方式
class A {
public:
	int operator() (const int &a, const int & b, std::promise<int> &promiseObj) const {
		promiseObj.set_value(a + b);
		return a + b;
	}
};

int main() {
	std::ios::sync_with_stdio(false);
	std::cin.tie(nullptr);
	A a;
	std::promise<int> promiseObj;
	std::future<int> futureObj = promiseObj.get_future();
	std::thread th1(a, 1, 2, std::ref(promiseObj));
	th1.join();
	watch(futureObj.get()); // 注意只能 get 一次。
	return 0;
}


#include <bits/stdc++.h>
#include <unistd.h>

// 生产者消费者问题
void solve() {
	std::queue<int> q;
	std::mutex mu;
	std::condition_variable cond;
	const int C = 3; // 最大产品量
	const int ST = 2; // 休眠时间
	auto producer = [&]() {
		std::srand(std::time(nullptr));
		while (1) {
			if(q.size() < C) { // 限流
				int data = std::rand();
				std::unique_lock<std::mutex> locker(mu);
				q.push(data);
				std::cout << "Saving " << data << std::endl;
				cond.notify_one(); // 通知取
			}
			sleep(ST);
		}
	};
	auto consumer = [&]() {
		while (1) {
			std::unique_lock<std::mutex> locker(mu);
			while (q.size() < C) cond.wait(locker); // 满了之后一次取完
			while (!q.empty()) {
				int data = q.front();
				q.pop();
				std::cout << "withdraw " << data << std::endl;
			}
			sleep(ST);
		}
	};
	std::thread t1(producer);
	std::thread t2(consumer);
	t1.join();
	t2.join();
}

int main() {
	solve();
	return 0;
}