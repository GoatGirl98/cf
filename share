#include <bits/stdc++.h>
#define watch(x) std::cout << (#x) << " is " << (x) << std::endl
using LL = long long;

template<int N>
class Nim {
	std::vector<int> sg, cnt;
public:
	Nim() : sg(N), cnt(N + 2) {
		for (int i = 1, msk = 0, m; i < N; ++i) {
			if (i & 1) {
				sg[i] = sg[i >> 1];
				continue;
			}
			if ((i & -i) == i) msk = i * 2 - 1;
			m = msk ^ i;
			for (int j = m; j; j = (j - 1) & m) {
				++cnt[sg[i - j]];
			}
			int r = 0;
			while (cnt[r]) ++r;
			sg[i] = r;
			for (int j = m; j; j = (j - 1) & m) {
				--cnt[sg[i - j]];
			}
		}
	}
	int solve(const std::vector<int> &a) {
		int r = 0;
		for (auto x : a) r ^= sg[x];
		return r;
	}
};

int main() {
	// freopen("in", "r", stdin);
	std::ios::sync_with_stdio(false);
	std::cin.tie(nullptr);
	auto start = std::clock();
	const int N = 1e5 + 2;
	Nim<N> A;
	int n;
	std::cin >> n;
	std::vector<int> a(n);
	for (auto &x : a) std::cin >> x;
	std::cout << A.solve(a) << "\n";
	std::cout << "Time used: " << (std::clock() - start) << "ms" << std::endl;
	return 0;
}

做法：考虑二进制，对于任意给定位，这一位的 1 的个数和都是 m 的倍数，那么就后手赢，否则先手赢。

对于否则的情况，我们总可以找到考虑最高位不是 m 的倍数，然后随便选择余数个（当前位为 1 的）进行改变。并且这些数后面的位是可以任意改变的。然后再继续往低位跑，显然，最终选取的个数总和小于 m。

// 每次选择在 x 堆(0 < x < m) 取石子，不能取的输
bool multNim(const std::vector<LL> &a, int m) {
	LL mx = *std::max_element(a.begin(), a.end());
	int ln = std::__lg(mx + 1) + 1;
	for (int i = 0; i < ln; ++i) {
		int cnt = 0;
		for (auto x : a) if ((x >> i) & 1) ++cnt;
		if (cnt % m) return true;
	}
	return false;
}